// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: schema/proto/model/common.proto

/*
Package model is a generated protocol buffer package.

It is generated from these files:
	schema/proto/model/common.proto

It has these top-level messages:
	Address
	Education
	Media
	Subscriptions
	SocialMedia
	Details
	Experience
	Investment
*/
package model

import context "context"
import fmt "fmt"
import strings "strings"
import time "time"

import errors1 "github.com/infobloxopen/protoc-gen-gorm/errors"
import field_mask1 "google.golang.org/genproto/protobuf/field_mask"
import gorm1 "github.com/jinzhu/gorm"
import gorm2 "github.com/infobloxopen/atlas-app-toolkit/gorm"
import pq1 "github.com/lib/pq"
import ptypes1 "github.com/golang/protobuf/ptypes"

import math "math"
import _ "github.com/golang/protobuf/ptypes/timestamp"

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = math.Inf

type AddressORM struct {
	BuildingNumber string
	City           string
	Country        string
	CreatedAt      *time.Time
	DeletedAt      *time.Time
	Id             int32 `gorm:"type:serial;primary_key"`
	Latitude       string
	Longitude      string
	State          string
	Street         string
	UpdatedAt      *time.Time
	ZipCode        string
}

// TableName overrides the default tablename generated by GORM
func (AddressORM) TableName() string {
	return "addresses"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Address) ToORM(ctx context.Context) (AddressORM, error) {
	to := AddressORM{}
	var err error
	if prehook, ok := interface{}(m).(AddressWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Longitude = m.Longitude
	to.Latitude = m.Latitude
	to.City = m.City
	to.State = m.State
	to.Country = m.Country
	to.ZipCode = m.ZipCode
	to.Street = m.Street
	to.BuildingNumber = m.BuildingNumber
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	if m.DeletedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.DeletedAt); err != nil {
			return to, err
		}
		to.DeletedAt = &t
	}
	if posthook, ok := interface{}(m).(AddressWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AddressORM) ToPB(ctx context.Context) (Address, error) {
	to := Address{}
	var err error
	if prehook, ok := interface{}(m).(AddressWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Longitude = m.Longitude
	to.Latitude = m.Latitude
	to.City = m.City
	to.State = m.State
	to.Country = m.Country
	to.ZipCode = m.ZipCode
	to.Street = m.Street
	to.BuildingNumber = m.BuildingNumber
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	if m.DeletedAt != nil {
		if to.DeletedAt, err = ptypes1.TimestampProto(*m.DeletedAt); err != nil {
			return to, err
		}
	}
	if posthook, ok := interface{}(m).(AddressWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Address the arg will be the target, the caller the one being converted from

// AddressBeforeToORM called before default ToORM code
type AddressWithBeforeToORM interface {
	BeforeToORM(context.Context, *AddressORM) error
}

// AddressAfterToORM called after default ToORM code
type AddressWithAfterToORM interface {
	AfterToORM(context.Context, *AddressORM) error
}

// AddressBeforeToPB called before default ToPB code
type AddressWithBeforeToPB interface {
	BeforeToPB(context.Context, *Address) error
}

// AddressAfterToPB called after default ToPB code
type AddressWithAfterToPB interface {
	AfterToPB(context.Context, *Address) error
}

type EducationORM struct {
	Activities         string
	CreatedAt          *time.Time
	CurrentlyAttending bool
	Degree             string
	DeletedAt          *time.Time
	Description        string
	EndDate            *time.Time
	FieldOfStudy       string
	Gpa                float32
	Id                 int32     `gorm:"type:serial;primary_key"`
	MediaId            *MediaORM `gorm:"foreignkey:EducationId;association_foreignkey:Id;preload:true"`
	School             string
	Societies          string
	StartDate          *time.Time
	UpdatedAt          *time.Time
}

// TableName overrides the default tablename generated by GORM
func (EducationORM) TableName() string {
	return "educations"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Education) ToORM(ctx context.Context) (EducationORM, error) {
	to := EducationORM{}
	var err error
	if prehook, ok := interface{}(m).(EducationWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.School = m.School
	to.Degree = m.Degree
	to.FieldOfStudy = m.FieldOfStudy
	if m.StartDate != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.StartDate); err != nil {
			return to, err
		}
		to.StartDate = &t
	}
	if m.EndDate != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.EndDate); err != nil {
			return to, err
		}
		to.EndDate = &t
	}
	to.CurrentlyAttending = m.CurrentlyAttending
	to.Gpa = m.Gpa
	to.Activities = m.Activities
	to.Societies = m.Societies
	to.Description = m.Description
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	if m.DeletedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.DeletedAt); err != nil {
			return to, err
		}
		to.DeletedAt = &t
	}
	if m.MediaId != nil {
		tempMediaId, err := m.MediaId.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.MediaId = &tempMediaId
	}
	if posthook, ok := interface{}(m).(EducationWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *EducationORM) ToPB(ctx context.Context) (Education, error) {
	to := Education{}
	var err error
	if prehook, ok := interface{}(m).(EducationWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.School = m.School
	to.Degree = m.Degree
	to.FieldOfStudy = m.FieldOfStudy
	if m.StartDate != nil {
		if to.StartDate, err = ptypes1.TimestampProto(*m.StartDate); err != nil {
			return to, err
		}
	}
	if m.EndDate != nil {
		if to.EndDate, err = ptypes1.TimestampProto(*m.EndDate); err != nil {
			return to, err
		}
	}
	to.CurrentlyAttending = m.CurrentlyAttending
	to.Gpa = m.Gpa
	to.Activities = m.Activities
	to.Societies = m.Societies
	to.Description = m.Description
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	if m.DeletedAt != nil {
		if to.DeletedAt, err = ptypes1.TimestampProto(*m.DeletedAt); err != nil {
			return to, err
		}
	}
	if m.MediaId != nil {
		tempMediaId, err := m.MediaId.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.MediaId = &tempMediaId
	}
	if posthook, ok := interface{}(m).(EducationWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Education the arg will be the target, the caller the one being converted from

// EducationBeforeToORM called before default ToORM code
type EducationWithBeforeToORM interface {
	BeforeToORM(context.Context, *EducationORM) error
}

// EducationAfterToORM called after default ToORM code
type EducationWithAfterToORM interface {
	AfterToORM(context.Context, *EducationORM) error
}

// EducationBeforeToPB called before default ToPB code
type EducationWithBeforeToPB interface {
	BeforeToPB(context.Context, *Education) error
}

// EducationAfterToPB called after default ToPB code
type EducationWithAfterToPB interface {
	AfterToPB(context.Context, *Education) error
}

type MediaORM struct {
	CreatedAt         *time.Time
	DeletedAt         *time.Time
	DocumentLinks     pq1.StringArray `gorm:"type:text[]"`
	EducationId       *int32
	ExperienceId      *int32
	Id                int32           `gorm:"type:serial;primary_key"`
	PhotoLinks        pq1.StringArray `gorm:"type:text[]"`
	PresentationLinks pq1.StringArray `gorm:"type:text[]"`
	UpdatedAt         *time.Time
	VideoLinks        pq1.StringArray `gorm:"type:text[]"`
}

// TableName overrides the default tablename generated by GORM
func (MediaORM) TableName() string {
	return "media"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Media) ToORM(ctx context.Context) (MediaORM, error) {
	to := MediaORM{}
	var err error
	if prehook, ok := interface{}(m).(MediaWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.DocumentLinks != nil {
		to.DocumentLinks = make(pq1.StringArray, len(m.DocumentLinks))
		copy(to.DocumentLinks, m.DocumentLinks)
	}
	if m.PhotoLinks != nil {
		to.PhotoLinks = make(pq1.StringArray, len(m.PhotoLinks))
		copy(to.PhotoLinks, m.PhotoLinks)
	}
	if m.VideoLinks != nil {
		to.VideoLinks = make(pq1.StringArray, len(m.VideoLinks))
		copy(to.VideoLinks, m.VideoLinks)
	}
	if m.PresentationLinks != nil {
		to.PresentationLinks = make(pq1.StringArray, len(m.PresentationLinks))
		copy(to.PresentationLinks, m.PresentationLinks)
	}
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.DeletedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.DeletedAt); err != nil {
			return to, err
		}
		to.DeletedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	if posthook, ok := interface{}(m).(MediaWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *MediaORM) ToPB(ctx context.Context) (Media, error) {
	to := Media{}
	var err error
	if prehook, ok := interface{}(m).(MediaWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.DocumentLinks != nil {
		to.DocumentLinks = make(pq1.StringArray, len(m.DocumentLinks))
		copy(to.DocumentLinks, m.DocumentLinks)
	}
	if m.PhotoLinks != nil {
		to.PhotoLinks = make(pq1.StringArray, len(m.PhotoLinks))
		copy(to.PhotoLinks, m.PhotoLinks)
	}
	if m.VideoLinks != nil {
		to.VideoLinks = make(pq1.StringArray, len(m.VideoLinks))
		copy(to.VideoLinks, m.VideoLinks)
	}
	if m.PresentationLinks != nil {
		to.PresentationLinks = make(pq1.StringArray, len(m.PresentationLinks))
		copy(to.PresentationLinks, m.PresentationLinks)
	}
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.DeletedAt != nil {
		if to.DeletedAt, err = ptypes1.TimestampProto(*m.DeletedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	if posthook, ok := interface{}(m).(MediaWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Media the arg will be the target, the caller the one being converted from

// MediaBeforeToORM called before default ToORM code
type MediaWithBeforeToORM interface {
	BeforeToORM(context.Context, *MediaORM) error
}

// MediaAfterToORM called after default ToORM code
type MediaWithAfterToORM interface {
	AfterToORM(context.Context, *MediaORM) error
}

// MediaBeforeToPB called before default ToPB code
type MediaWithBeforeToPB interface {
	BeforeToPB(context.Context, *Media) error
}

// MediaAfterToPB called after default ToPB code
type MediaWithAfterToPB interface {
	AfterToPB(context.Context, *Media) error
}

type SubscriptionsORM struct {
	AccessType         string
	CreatedAt          *time.Time
	DeletedAt          *time.Time
	EndDate            *time.Time
	Id                 uint32 `gorm:"type:serial;primary_key"`
	IsActive           bool
	StartDate          *time.Time
	SubscriptionName   string
	SubscriptionStatus string
	UpdatedAt          *time.Time
}

// TableName overrides the default tablename generated by GORM
func (SubscriptionsORM) TableName() string {
	return "subscriptions"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Subscriptions) ToORM(ctx context.Context) (SubscriptionsORM, error) {
	to := SubscriptionsORM{}
	var err error
	if prehook, ok := interface{}(m).(SubscriptionsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.SubscriptionName = m.SubscriptionName
	to.SubscriptionStatus = m.SubscriptionStatus
	if m.StartDate != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.StartDate); err != nil {
			return to, err
		}
		to.StartDate = &t
	}
	if m.EndDate != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.EndDate); err != nil {
			return to, err
		}
		to.EndDate = &t
	}
	to.AccessType = m.AccessType
	to.IsActive = m.IsActive
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.DeletedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.DeletedAt); err != nil {
			return to, err
		}
		to.DeletedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	if posthook, ok := interface{}(m).(SubscriptionsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *SubscriptionsORM) ToPB(ctx context.Context) (Subscriptions, error) {
	to := Subscriptions{}
	var err error
	if prehook, ok := interface{}(m).(SubscriptionsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.SubscriptionName = m.SubscriptionName
	to.SubscriptionStatus = m.SubscriptionStatus
	if m.StartDate != nil {
		if to.StartDate, err = ptypes1.TimestampProto(*m.StartDate); err != nil {
			return to, err
		}
	}
	if m.EndDate != nil {
		if to.EndDate, err = ptypes1.TimestampProto(*m.EndDate); err != nil {
			return to, err
		}
	}
	to.AccessType = m.AccessType
	to.IsActive = m.IsActive
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.DeletedAt != nil {
		if to.DeletedAt, err = ptypes1.TimestampProto(*m.DeletedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	if posthook, ok := interface{}(m).(SubscriptionsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Subscriptions the arg will be the target, the caller the one being converted from

// SubscriptionsBeforeToORM called before default ToORM code
type SubscriptionsWithBeforeToORM interface {
	BeforeToORM(context.Context, *SubscriptionsORM) error
}

// SubscriptionsAfterToORM called after default ToORM code
type SubscriptionsWithAfterToORM interface {
	AfterToORM(context.Context, *SubscriptionsORM) error
}

// SubscriptionsBeforeToPB called before default ToPB code
type SubscriptionsWithBeforeToPB interface {
	BeforeToPB(context.Context, *Subscriptions) error
}

// SubscriptionsAfterToPB called after default ToPB code
type SubscriptionsWithAfterToPB interface {
	AfterToPB(context.Context, *Subscriptions) error
}

type SocialMediaORM struct {
	CreatedAt   *time.Time
	DeletedAt   *time.Time
	FacebookUrl string
	GithubUrl   uint32
	Id          int32 `gorm:"type:serial;primary_key"`
	LinkedUrl   string
	TwitterUrl  string
	UpdatedAt   *time.Time
	WebsiteUrl  string
	YoutubeUrl  string
}

// TableName overrides the default tablename generated by GORM
func (SocialMediaORM) TableName() string {
	return "social_media"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *SocialMedia) ToORM(ctx context.Context) (SocialMediaORM, error) {
	to := SocialMediaORM{}
	var err error
	if prehook, ok := interface{}(m).(SocialMediaWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.GithubUrl = m.GithubUrl
	to.WebsiteUrl = m.WebsiteUrl
	to.FacebookUrl = m.FacebookUrl
	to.TwitterUrl = m.TwitterUrl
	to.LinkedUrl = m.LinkedUrl
	to.YoutubeUrl = m.YoutubeUrl
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.DeletedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.DeletedAt); err != nil {
			return to, err
		}
		to.DeletedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	if posthook, ok := interface{}(m).(SocialMediaWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *SocialMediaORM) ToPB(ctx context.Context) (SocialMedia, error) {
	to := SocialMedia{}
	var err error
	if prehook, ok := interface{}(m).(SocialMediaWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.GithubUrl = m.GithubUrl
	to.WebsiteUrl = m.WebsiteUrl
	to.FacebookUrl = m.FacebookUrl
	to.TwitterUrl = m.TwitterUrl
	to.LinkedUrl = m.LinkedUrl
	to.YoutubeUrl = m.YoutubeUrl
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.DeletedAt != nil {
		if to.DeletedAt, err = ptypes1.TimestampProto(*m.DeletedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	if posthook, ok := interface{}(m).(SocialMediaWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type SocialMedia the arg will be the target, the caller the one being converted from

// SocialMediaBeforeToORM called before default ToORM code
type SocialMediaWithBeforeToORM interface {
	BeforeToORM(context.Context, *SocialMediaORM) error
}

// SocialMediaAfterToORM called after default ToORM code
type SocialMediaWithAfterToORM interface {
	AfterToORM(context.Context, *SocialMediaORM) error
}

// SocialMediaBeforeToPB called before default ToPB code
type SocialMediaWithBeforeToPB interface {
	BeforeToPB(context.Context, *SocialMedia) error
}

// SocialMediaAfterToPB called after default ToPB code
type SocialMediaWithAfterToPB interface {
	AfterToPB(context.Context, *SocialMedia) error
}

type DetailsORM struct {
	CompanyType string
	IPOStatus   string
}

// TableName overrides the default tablename generated by GORM
func (DetailsORM) TableName() string {
	return "details"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Details) ToORM(ctx context.Context) (DetailsORM, error) {
	to := DetailsORM{}
	var err error
	if prehook, ok := interface{}(m).(DetailsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.IPOStatus = m.IPOStatus
	to.CompanyType = m.CompanyType
	if posthook, ok := interface{}(m).(DetailsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *DetailsORM) ToPB(ctx context.Context) (Details, error) {
	to := Details{}
	var err error
	if prehook, ok := interface{}(m).(DetailsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.IPOStatus = m.IPOStatus
	to.CompanyType = m.CompanyType
	if posthook, ok := interface{}(m).(DetailsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Details the arg will be the target, the caller the one being converted from

// DetailsBeforeToORM called before default ToORM code
type DetailsWithBeforeToORM interface {
	BeforeToORM(context.Context, *DetailsORM) error
}

// DetailsAfterToORM called after default ToORM code
type DetailsWithAfterToORM interface {
	AfterToORM(context.Context, *DetailsORM) error
}

// DetailsBeforeToPB called before default ToPB code
type DetailsWithBeforeToPB interface {
	BeforeToPB(context.Context, *Details) error
}

// DetailsAfterToPB called after default ToPB code
type DetailsWithAfterToPB interface {
	AfterToPB(context.Context, *Details) error
}

type ExperienceORM struct {
	CompanyName    string
	CreatedAt      *time.Time
	DeletedAt      *time.Time
	Description    string
	EmploymentType string
	EndDate        *time.Time
	Headline       string
	Id             int32 `gorm:"type:serial;primary_key"`
	IsCurrentJob   bool
	Location       string
	MediaId        *MediaORM `gorm:"foreignkey:ExperienceId;association_foreignkey:Id"`
	StartDate      *time.Time
	Title          string
	UpdatedAt      *time.Time
}

// TableName overrides the default tablename generated by GORM
func (ExperienceORM) TableName() string {
	return "experiences"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Experience) ToORM(ctx context.Context) (ExperienceORM, error) {
	to := ExperienceORM{}
	var err error
	if prehook, ok := interface{}(m).(ExperienceWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.CompanyName = m.CompanyName
	to.Title = m.Title
	to.EmploymentType = m.EmploymentType
	to.Location = m.Location
	if m.StartDate != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.StartDate); err != nil {
			return to, err
		}
		to.StartDate = &t
	}
	if m.EndDate != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.EndDate); err != nil {
			return to, err
		}
		to.EndDate = &t
	}
	to.IsCurrentJob = m.IsCurrentJob
	to.Headline = m.Headline
	to.Description = m.Description
	if m.MediaId != nil {
		tempMediaId, err := m.MediaId.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.MediaId = &tempMediaId
	}
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	if m.DeletedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.DeletedAt); err != nil {
			return to, err
		}
		to.DeletedAt = &t
	}
	if posthook, ok := interface{}(m).(ExperienceWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ExperienceORM) ToPB(ctx context.Context) (Experience, error) {
	to := Experience{}
	var err error
	if prehook, ok := interface{}(m).(ExperienceWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.CompanyName = m.CompanyName
	to.Title = m.Title
	to.EmploymentType = m.EmploymentType
	to.Location = m.Location
	if m.StartDate != nil {
		if to.StartDate, err = ptypes1.TimestampProto(*m.StartDate); err != nil {
			return to, err
		}
	}
	if m.EndDate != nil {
		if to.EndDate, err = ptypes1.TimestampProto(*m.EndDate); err != nil {
			return to, err
		}
	}
	to.IsCurrentJob = m.IsCurrentJob
	to.Headline = m.Headline
	to.Description = m.Description
	if m.MediaId != nil {
		tempMediaId, err := m.MediaId.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.MediaId = &tempMediaId
	}
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	if m.DeletedAt != nil {
		if to.DeletedAt, err = ptypes1.TimestampProto(*m.DeletedAt); err != nil {
			return to, err
		}
	}
	if posthook, ok := interface{}(m).(ExperienceWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Experience the arg will be the target, the caller the one being converted from

// ExperienceBeforeToORM called before default ToORM code
type ExperienceWithBeforeToORM interface {
	BeforeToORM(context.Context, *ExperienceORM) error
}

// ExperienceAfterToORM called after default ToORM code
type ExperienceWithAfterToORM interface {
	AfterToORM(context.Context, *ExperienceORM) error
}

// ExperienceBeforeToPB called before default ToPB code
type ExperienceWithBeforeToPB interface {
	BeforeToPB(context.Context, *Experience) error
}

// ExperienceAfterToPB called after default ToPB code
type ExperienceWithAfterToPB interface {
	AfterToPB(context.Context, *Experience) error
}

type InvestmentORM struct {
	CompanyName string
	Id          int32 `gorm:"type:serial;primary_key"`
	Industry    string
}

// TableName overrides the default tablename generated by GORM
func (InvestmentORM) TableName() string {
	return "investments"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Investment) ToORM(ctx context.Context) (InvestmentORM, error) {
	to := InvestmentORM{}
	var err error
	if prehook, ok := interface{}(m).(InvestmentWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.CompanyName = m.CompanyName
	to.Industry = m.Industry
	if posthook, ok := interface{}(m).(InvestmentWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *InvestmentORM) ToPB(ctx context.Context) (Investment, error) {
	to := Investment{}
	var err error
	if prehook, ok := interface{}(m).(InvestmentWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.CompanyName = m.CompanyName
	to.Industry = m.Industry
	if posthook, ok := interface{}(m).(InvestmentWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Investment the arg will be the target, the caller the one being converted from

// InvestmentBeforeToORM called before default ToORM code
type InvestmentWithBeforeToORM interface {
	BeforeToORM(context.Context, *InvestmentORM) error
}

// InvestmentAfterToORM called after default ToORM code
type InvestmentWithAfterToORM interface {
	AfterToORM(context.Context, *InvestmentORM) error
}

// InvestmentBeforeToPB called before default ToPB code
type InvestmentWithBeforeToPB interface {
	BeforeToPB(context.Context, *Investment) error
}

// InvestmentAfterToPB called after default ToPB code
type InvestmentWithAfterToPB interface {
	AfterToPB(context.Context, *Investment) error
}

// DefaultCreateAddress executes a basic gorm create call
func DefaultCreateAddress(ctx context.Context, in *Address, db *gorm1.DB) (*Address, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AddressORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AddressORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadAddress executes a basic gorm read call
func DefaultReadAddress(ctx context.Context, in *Address, db *gorm1.DB) (*Address, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &AddressORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := AddressORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AddressORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AddressORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AddressORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AddressORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteAddress(ctx context.Context, in *Address, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AddressORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type AddressORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AddressORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteAddressSet(ctx context.Context, in []*Address, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AddressORM{})).(AddressORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&AddressORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AddressORM{})).(AddressORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AddressORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Address, *gorm1.DB) (*gorm1.DB, error)
}
type AddressORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Address, *gorm1.DB) error
}

// DefaultStrictUpdateAddress clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAddress(ctx context.Context, in *Address, db *gorm1.DB) (*Address, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAddress")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &AddressORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AddressORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AddressORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AddressORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchAddress executes a basic gorm update call with patch behavior
func DefaultPatchAddress(ctx context.Context, in *Address, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Address, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Address
	var err error
	if hook, ok := interface{}(&pbObj).(AddressWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAddress(ctx, &Address{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AddressWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAddress(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AddressWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAddress(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AddressWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AddressWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Address, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type AddressWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Address, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type AddressWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Address, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type AddressWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Address, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetAddress executes a bulk gorm update call with patch behavior
func DefaultPatchSetAddress(ctx context.Context, objects []*Address, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Address, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Address, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchAddress(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskAddress patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAddress(ctx context.Context, patchee *Address, patcher *Address, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Address, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Longitude" {
			patchee.Longitude = patcher.Longitude
			continue
		}
		if f == prefix+"Latitude" {
			patchee.Latitude = patcher.Latitude
			continue
		}
		if f == prefix+"City" {
			patchee.City = patcher.City
			continue
		}
		if f == prefix+"State" {
			patchee.State = patcher.State
			continue
		}
		if f == prefix+"Country" {
			patchee.Country = patcher.Country
			continue
		}
		if f == prefix+"ZipCode" {
			patchee.ZipCode = patcher.ZipCode
			continue
		}
		if f == prefix+"Street" {
			patchee.Street = patcher.Street
			continue
		}
		if f == prefix+"BuildingNumber" {
			patchee.BuildingNumber = patcher.BuildingNumber
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"DeletedAt" {
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAddress executes a gorm list call
func DefaultListAddress(ctx context.Context, db *gorm1.DB) ([]*Address, error) {
	in := Address{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &AddressORM{}, &Address{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AddressORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Address{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AddressORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AddressORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AddressORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]AddressORM) error
}

// DefaultCreateEducation executes a basic gorm create call
func DefaultCreateEducation(ctx context.Context, in *Education, db *gorm1.DB) (*Education, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EducationORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EducationORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type EducationORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type EducationORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadEducation executes a basic gorm read call
func DefaultReadEducation(ctx context.Context, in *Education, db *gorm1.DB) (*Education, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(EducationORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &EducationORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EducationORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := EducationORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(EducationORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type EducationORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type EducationORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type EducationORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteEducation(ctx context.Context, in *Education, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(EducationORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&EducationORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(EducationORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type EducationORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type EducationORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteEducationSet(ctx context.Context, in []*Education, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&EducationORM{})).(EducationORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&EducationORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&EducationORM{})).(EducationORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type EducationORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Education, *gorm1.DB) (*gorm1.DB, error)
}
type EducationORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Education, *gorm1.DB) error
}

// DefaultStrictUpdateEducation clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateEducation(ctx context.Context, in *Education, db *gorm1.DB) (*Education, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateEducation")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &EducationORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(EducationORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterMediaId := MediaORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterMediaId.EducationId = new(int32)
	*filterMediaId.EducationId = ormObj.Id
	if err = db.Where(filterMediaId).Delete(MediaORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EducationORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EducationORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type EducationORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type EducationORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type EducationORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchEducation executes a basic gorm update call with patch behavior
func DefaultPatchEducation(ctx context.Context, in *Education, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Education, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Education
	var err error
	if hook, ok := interface{}(&pbObj).(EducationWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadEducation(ctx, &Education{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(EducationWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskEducation(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(EducationWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateEducation(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(EducationWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type EducationWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Education, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type EducationWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Education, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type EducationWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Education, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type EducationWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Education, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetEducation executes a bulk gorm update call with patch behavior
func DefaultPatchSetEducation(ctx context.Context, objects []*Education, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Education, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Education, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchEducation(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskEducation patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskEducation(ctx context.Context, patchee *Education, patcher *Education, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Education, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedMediaId bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"School" {
			patchee.School = patcher.School
			continue
		}
		if f == prefix+"Degree" {
			patchee.Degree = patcher.Degree
			continue
		}
		if f == prefix+"FieldOfStudy" {
			patchee.FieldOfStudy = patcher.FieldOfStudy
			continue
		}
		if f == prefix+"StartDate" {
			patchee.StartDate = patcher.StartDate
			continue
		}
		if f == prefix+"EndDate" {
			patchee.EndDate = patcher.EndDate
			continue
		}
		if f == prefix+"CurrentlyAttending" {
			patchee.CurrentlyAttending = patcher.CurrentlyAttending
			continue
		}
		if f == prefix+"Gpa" {
			patchee.Gpa = patcher.Gpa
			continue
		}
		if f == prefix+"Activities" {
			patchee.Activities = patcher.Activities
			continue
		}
		if f == prefix+"Societies" {
			patchee.Societies = patcher.Societies
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"DeletedAt" {
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if !updatedMediaId && strings.HasPrefix(f, prefix+"MediaId.") {
			updatedMediaId = true
			if patcher.MediaId == nil {
				patchee.MediaId = nil
				continue
			}
			if patchee.MediaId == nil {
				patchee.MediaId = &Media{}
			}
			if o, err := DefaultApplyFieldMaskMedia(ctx, patchee.MediaId, patcher.MediaId, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"MediaId.", db); err != nil {
				return nil, err
			} else {
				patchee.MediaId = o
			}
			continue
		}
		if f == prefix+"MediaId" {
			updatedMediaId = true
			patchee.MediaId = patcher.MediaId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListEducation executes a gorm list call
func DefaultListEducation(ctx context.Context, db *gorm1.DB) ([]*Education, error) {
	in := Education{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EducationORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &EducationORM{}, &Education{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EducationORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []EducationORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EducationORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Education{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type EducationORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type EducationORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type EducationORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]EducationORM) error
}

// DefaultCreateMedia executes a basic gorm create call
func DefaultCreateMedia(ctx context.Context, in *Media, db *gorm1.DB) (*Media, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MediaORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MediaORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type MediaORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type MediaORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadMedia executes a basic gorm read call
func DefaultReadMedia(ctx context.Context, in *Media, db *gorm1.DB) (*Media, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MediaORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &MediaORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MediaORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := MediaORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(MediaORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type MediaORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type MediaORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type MediaORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteMedia(ctx context.Context, in *Media, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MediaORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&MediaORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(MediaORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type MediaORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type MediaORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteMediaSet(ctx context.Context, in []*Media, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&MediaORM{})).(MediaORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&MediaORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&MediaORM{})).(MediaORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type MediaORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Media, *gorm1.DB) (*gorm1.DB, error)
}
type MediaORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Media, *gorm1.DB) error
}

// DefaultStrictUpdateMedia clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateMedia(ctx context.Context, in *Media, db *gorm1.DB) (*Media, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateMedia")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &MediaORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(MediaORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(MediaORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MediaORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type MediaORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type MediaORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type MediaORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchMedia executes a basic gorm update call with patch behavior
func DefaultPatchMedia(ctx context.Context, in *Media, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Media, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Media
	var err error
	if hook, ok := interface{}(&pbObj).(MediaWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadMedia(ctx, &Media{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(MediaWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskMedia(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(MediaWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateMedia(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(MediaWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type MediaWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Media, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type MediaWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Media, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type MediaWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Media, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type MediaWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Media, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetMedia executes a bulk gorm update call with patch behavior
func DefaultPatchSetMedia(ctx context.Context, objects []*Media, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Media, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Media, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchMedia(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskMedia patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskMedia(ctx context.Context, patchee *Media, patcher *Media, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Media, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"DocumentLinks" {
			patchee.DocumentLinks = patcher.DocumentLinks
			continue
		}
		if f == prefix+"PhotoLinks" {
			patchee.PhotoLinks = patcher.PhotoLinks
			continue
		}
		if f == prefix+"VideoLinks" {
			patchee.VideoLinks = patcher.VideoLinks
			continue
		}
		if f == prefix+"PresentationLinks" {
			patchee.PresentationLinks = patcher.PresentationLinks
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"DeletedAt" {
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListMedia executes a gorm list call
func DefaultListMedia(ctx context.Context, db *gorm1.DB) ([]*Media, error) {
	in := Media{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MediaORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &MediaORM{}, &Media{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MediaORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []MediaORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MediaORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Media{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type MediaORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type MediaORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type MediaORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]MediaORM) error
}

// DefaultCreateSubscriptions executes a basic gorm create call
func DefaultCreateSubscriptions(ctx context.Context, in *Subscriptions, db *gorm1.DB) (*Subscriptions, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SubscriptionsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SubscriptionsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type SubscriptionsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SubscriptionsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadSubscriptions executes a basic gorm read call
func DefaultReadSubscriptions(ctx context.Context, in *Subscriptions, db *gorm1.DB) (*Subscriptions, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(SubscriptionsORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &SubscriptionsORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SubscriptionsORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := SubscriptionsORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(SubscriptionsORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type SubscriptionsORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SubscriptionsORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SubscriptionsORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteSubscriptions(ctx context.Context, in *Subscriptions, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(SubscriptionsORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&SubscriptionsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(SubscriptionsORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type SubscriptionsORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SubscriptionsORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteSubscriptionsSet(ctx context.Context, in []*Subscriptions, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []uint32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&SubscriptionsORM{})).(SubscriptionsORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&SubscriptionsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&SubscriptionsORM{})).(SubscriptionsORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type SubscriptionsORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Subscriptions, *gorm1.DB) (*gorm1.DB, error)
}
type SubscriptionsORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Subscriptions, *gorm1.DB) error
}

// DefaultStrictUpdateSubscriptions clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateSubscriptions(ctx context.Context, in *Subscriptions, db *gorm1.DB) (*Subscriptions, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateSubscriptions")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &SubscriptionsORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(SubscriptionsORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(SubscriptionsORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SubscriptionsORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type SubscriptionsORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SubscriptionsORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SubscriptionsORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchSubscriptions executes a basic gorm update call with patch behavior
func DefaultPatchSubscriptions(ctx context.Context, in *Subscriptions, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Subscriptions, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Subscriptions
	var err error
	if hook, ok := interface{}(&pbObj).(SubscriptionsWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadSubscriptions(ctx, &Subscriptions{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(SubscriptionsWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskSubscriptions(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(SubscriptionsWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateSubscriptions(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(SubscriptionsWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type SubscriptionsWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Subscriptions, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type SubscriptionsWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Subscriptions, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type SubscriptionsWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Subscriptions, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type SubscriptionsWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Subscriptions, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetSubscriptions executes a bulk gorm update call with patch behavior
func DefaultPatchSetSubscriptions(ctx context.Context, objects []*Subscriptions, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Subscriptions, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Subscriptions, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchSubscriptions(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskSubscriptions patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskSubscriptions(ctx context.Context, patchee *Subscriptions, patcher *Subscriptions, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Subscriptions, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"SubscriptionName" {
			patchee.SubscriptionName = patcher.SubscriptionName
			continue
		}
		if f == prefix+"SubscriptionStatus" {
			patchee.SubscriptionStatus = patcher.SubscriptionStatus
			continue
		}
		if f == prefix+"StartDate" {
			patchee.StartDate = patcher.StartDate
			continue
		}
		if f == prefix+"EndDate" {
			patchee.EndDate = patcher.EndDate
			continue
		}
		if f == prefix+"AccessType" {
			patchee.AccessType = patcher.AccessType
			continue
		}
		if f == prefix+"IsActive" {
			patchee.IsActive = patcher.IsActive
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"DeletedAt" {
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListSubscriptions executes a gorm list call
func DefaultListSubscriptions(ctx context.Context, db *gorm1.DB) ([]*Subscriptions, error) {
	in := Subscriptions{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SubscriptionsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &SubscriptionsORM{}, &Subscriptions{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SubscriptionsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []SubscriptionsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SubscriptionsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Subscriptions{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type SubscriptionsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SubscriptionsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SubscriptionsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]SubscriptionsORM) error
}

// DefaultCreateSocialMedia executes a basic gorm create call
func DefaultCreateSocialMedia(ctx context.Context, in *SocialMedia, db *gorm1.DB) (*SocialMedia, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SocialMediaORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SocialMediaORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type SocialMediaORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SocialMediaORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadSocialMedia executes a basic gorm read call
func DefaultReadSocialMedia(ctx context.Context, in *SocialMedia, db *gorm1.DB) (*SocialMedia, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(SocialMediaORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &SocialMediaORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SocialMediaORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := SocialMediaORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(SocialMediaORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type SocialMediaORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SocialMediaORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SocialMediaORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteSocialMedia(ctx context.Context, in *SocialMedia, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(SocialMediaORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&SocialMediaORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(SocialMediaORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type SocialMediaORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SocialMediaORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteSocialMediaSet(ctx context.Context, in []*SocialMedia, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&SocialMediaORM{})).(SocialMediaORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&SocialMediaORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&SocialMediaORM{})).(SocialMediaORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type SocialMediaORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*SocialMedia, *gorm1.DB) (*gorm1.DB, error)
}
type SocialMediaORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*SocialMedia, *gorm1.DB) error
}

// DefaultStrictUpdateSocialMedia clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateSocialMedia(ctx context.Context, in *SocialMedia, db *gorm1.DB) (*SocialMedia, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateSocialMedia")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &SocialMediaORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(SocialMediaORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(SocialMediaORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SocialMediaORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type SocialMediaORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SocialMediaORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SocialMediaORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchSocialMedia executes a basic gorm update call with patch behavior
func DefaultPatchSocialMedia(ctx context.Context, in *SocialMedia, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*SocialMedia, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj SocialMedia
	var err error
	if hook, ok := interface{}(&pbObj).(SocialMediaWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadSocialMedia(ctx, &SocialMedia{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(SocialMediaWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskSocialMedia(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(SocialMediaWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateSocialMedia(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(SocialMediaWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type SocialMediaWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *SocialMedia, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type SocialMediaWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *SocialMedia, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type SocialMediaWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *SocialMedia, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type SocialMediaWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *SocialMedia, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetSocialMedia executes a bulk gorm update call with patch behavior
func DefaultPatchSetSocialMedia(ctx context.Context, objects []*SocialMedia, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*SocialMedia, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*SocialMedia, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchSocialMedia(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskSocialMedia patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskSocialMedia(ctx context.Context, patchee *SocialMedia, patcher *SocialMedia, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*SocialMedia, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"GithubUrl" {
			patchee.GithubUrl = patcher.GithubUrl
			continue
		}
		if f == prefix+"WebsiteUrl" {
			patchee.WebsiteUrl = patcher.WebsiteUrl
			continue
		}
		if f == prefix+"FacebookUrl" {
			patchee.FacebookUrl = patcher.FacebookUrl
			continue
		}
		if f == prefix+"TwitterUrl" {
			patchee.TwitterUrl = patcher.TwitterUrl
			continue
		}
		if f == prefix+"LinkedUrl" {
			patchee.LinkedUrl = patcher.LinkedUrl
			continue
		}
		if f == prefix+"YoutubeUrl" {
			patchee.YoutubeUrl = patcher.YoutubeUrl
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"DeletedAt" {
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListSocialMedia executes a gorm list call
func DefaultListSocialMedia(ctx context.Context, db *gorm1.DB) ([]*SocialMedia, error) {
	in := SocialMedia{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SocialMediaORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &SocialMediaORM{}, &SocialMedia{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SocialMediaORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []SocialMediaORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SocialMediaORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*SocialMedia{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type SocialMediaORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SocialMediaORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SocialMediaORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]SocialMediaORM) error
}

// DefaultCreateDetails executes a basic gorm create call
func DefaultCreateDetails(ctx context.Context, in *Details, db *gorm1.DB) (*Details, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DetailsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DetailsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type DetailsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type DetailsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultApplyFieldMaskDetails patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskDetails(ctx context.Context, patchee *Details, patcher *Details, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Details, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"IPOStatus" {
			patchee.IPOStatus = patcher.IPOStatus
			continue
		}
		if f == prefix+"CompanyType" {
			patchee.CompanyType = patcher.CompanyType
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListDetails executes a gorm list call
func DefaultListDetails(ctx context.Context, db *gorm1.DB) ([]*Details, error) {
	in := Details{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DetailsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &DetailsORM{}, &Details{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DetailsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	ormResponse := []DetailsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DetailsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Details{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type DetailsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type DetailsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type DetailsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]DetailsORM) error
}

// DefaultCreateExperience executes a basic gorm create call
func DefaultCreateExperience(ctx context.Context, in *Experience, db *gorm1.DB) (*Experience, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExperienceORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExperienceORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ExperienceORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ExperienceORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadExperience executes a basic gorm read call
func DefaultReadExperience(ctx context.Context, in *Experience, db *gorm1.DB) (*Experience, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ExperienceORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &ExperienceORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExperienceORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ExperienceORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ExperienceORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ExperienceORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ExperienceORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ExperienceORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteExperience(ctx context.Context, in *Experience, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ExperienceORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ExperienceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ExperienceORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ExperienceORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ExperienceORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteExperienceSet(ctx context.Context, in []*Experience, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ExperienceORM{})).(ExperienceORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ExperienceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ExperienceORM{})).(ExperienceORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ExperienceORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Experience, *gorm1.DB) (*gorm1.DB, error)
}
type ExperienceORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Experience, *gorm1.DB) error
}

// DefaultStrictUpdateExperience clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateExperience(ctx context.Context, in *Experience, db *gorm1.DB) (*Experience, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateExperience")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ExperienceORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ExperienceORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterMediaId := MediaORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterMediaId.ExperienceId = new(int32)
	*filterMediaId.ExperienceId = ormObj.Id
	if err = db.Where(filterMediaId).Delete(MediaORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExperienceORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExperienceORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ExperienceORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ExperienceORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ExperienceORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchExperience executes a basic gorm update call with patch behavior
func DefaultPatchExperience(ctx context.Context, in *Experience, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Experience, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Experience
	var err error
	if hook, ok := interface{}(&pbObj).(ExperienceWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadExperience(ctx, &Experience{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ExperienceWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskExperience(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ExperienceWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateExperience(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ExperienceWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ExperienceWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Experience, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ExperienceWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Experience, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ExperienceWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Experience, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ExperienceWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Experience, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetExperience executes a bulk gorm update call with patch behavior
func DefaultPatchSetExperience(ctx context.Context, objects []*Experience, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Experience, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Experience, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchExperience(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskExperience patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskExperience(ctx context.Context, patchee *Experience, patcher *Experience, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Experience, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedMediaId bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CompanyName" {
			patchee.CompanyName = patcher.CompanyName
			continue
		}
		if f == prefix+"Title" {
			patchee.Title = patcher.Title
			continue
		}
		if f == prefix+"EmploymentType" {
			patchee.EmploymentType = patcher.EmploymentType
			continue
		}
		if f == prefix+"Location" {
			patchee.Location = patcher.Location
			continue
		}
		if f == prefix+"StartDate" {
			patchee.StartDate = patcher.StartDate
			continue
		}
		if f == prefix+"EndDate" {
			patchee.EndDate = patcher.EndDate
			continue
		}
		if f == prefix+"IsCurrentJob" {
			patchee.IsCurrentJob = patcher.IsCurrentJob
			continue
		}
		if f == prefix+"Headline" {
			patchee.Headline = patcher.Headline
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if !updatedMediaId && strings.HasPrefix(f, prefix+"MediaId.") {
			updatedMediaId = true
			if patcher.MediaId == nil {
				patchee.MediaId = nil
				continue
			}
			if patchee.MediaId == nil {
				patchee.MediaId = &Media{}
			}
			if o, err := DefaultApplyFieldMaskMedia(ctx, patchee.MediaId, patcher.MediaId, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"MediaId.", db); err != nil {
				return nil, err
			} else {
				patchee.MediaId = o
			}
			continue
		}
		if f == prefix+"MediaId" {
			updatedMediaId = true
			patchee.MediaId = patcher.MediaId
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"DeletedAt" {
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListExperience executes a gorm list call
func DefaultListExperience(ctx context.Context, db *gorm1.DB) ([]*Experience, error) {
	in := Experience{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExperienceORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ExperienceORM{}, &Experience{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExperienceORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ExperienceORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExperienceORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Experience{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ExperienceORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ExperienceORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ExperienceORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ExperienceORM) error
}

// DefaultCreateInvestment executes a basic gorm create call
func DefaultCreateInvestment(ctx context.Context, in *Investment, db *gorm1.DB) (*Investment, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type InvestmentORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type InvestmentORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadInvestment executes a basic gorm read call
func DefaultReadInvestment(ctx context.Context, in *Investment, db *gorm1.DB) (*Investment, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(InvestmentORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &InvestmentORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := InvestmentORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(InvestmentORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type InvestmentORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type InvestmentORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type InvestmentORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteInvestment(ctx context.Context, in *Investment, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(InvestmentORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&InvestmentORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type InvestmentORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type InvestmentORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteInvestmentSet(ctx context.Context, in []*Investment, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&InvestmentORM{})).(InvestmentORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&InvestmentORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&InvestmentORM{})).(InvestmentORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type InvestmentORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Investment, *gorm1.DB) (*gorm1.DB, error)
}
type InvestmentORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Investment, *gorm1.DB) error
}

// DefaultStrictUpdateInvestment clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateInvestment(ctx context.Context, in *Investment, db *gorm1.DB) (*Investment, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateInvestment")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &InvestmentORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(InvestmentORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(InvestmentORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type InvestmentORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type InvestmentORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type InvestmentORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchInvestment executes a basic gorm update call with patch behavior
func DefaultPatchInvestment(ctx context.Context, in *Investment, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Investment, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Investment
	var err error
	if hook, ok := interface{}(&pbObj).(InvestmentWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadInvestment(ctx, &Investment{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(InvestmentWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskInvestment(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(InvestmentWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateInvestment(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(InvestmentWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type InvestmentWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Investment, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type InvestmentWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Investment, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type InvestmentWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Investment, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type InvestmentWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Investment, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetInvestment executes a bulk gorm update call with patch behavior
func DefaultPatchSetInvestment(ctx context.Context, objects []*Investment, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Investment, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Investment, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchInvestment(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskInvestment patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskInvestment(ctx context.Context, patchee *Investment, patcher *Investment, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Investment, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CompanyName" {
			patchee.CompanyName = patcher.CompanyName
			continue
		}
		if f == prefix+"Industry" {
			patchee.Industry = patcher.Industry
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListInvestment executes a gorm list call
func DefaultListInvestment(ctx context.Context, db *gorm1.DB) ([]*Investment, error) {
	in := Investment{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &InvestmentORM{}, &Investment{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []InvestmentORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Investment{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type InvestmentORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type InvestmentORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type InvestmentORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]InvestmentORM) error
}
